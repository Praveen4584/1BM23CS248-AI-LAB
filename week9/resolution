## Function Definitions for PL Resolution

# Note: The 'unify', 'unify_var', 'substitute', and 'occur_check' functions 
# are part of a general first-order logic (FOL) unification system. 
# While they are defined here, they are NOT strictly necessary for the 
# pl_resolution function, which deals only with propositional logic strings 
# (like 'P' and '¬P'). I will keep them as you provided them, but they 
# remain unused in the final pl_resolution execution.

def is_variable(x):
    """Checks if x is a lowercase variable (for FOL)."""
    return isinstance(x, str) and x[0].islower()

def substitute(expr, subst):
    """Apply a substitution mapping to an expression (for FOL)."""
    if isinstance(expr, list):
        return [substitute(e, subst) for e in expr] 
    for (var, val) in subst.items():
        if expr == var: 
            return val
    return expr

def unify(x, y, subst=None): 
    """Unification algorithm (for FOL).""" 
    if subst is None:
        subst = {} 
    if x == y:
        return subst
    if is_variable(x):
        return unify_var(x, y, subst) 
    if is_variable(y):
        return unify_var(y, x, subst)
    if isinstance(x, list) and isinstance(y, list): 
        if len(x) != len(y) or x[0] != y[0]:
            return None
        for i in range(1, len(x)):
            subst = unify(substitute(x[i], subst), substitute(y[i], subst), subst) 
            if subst is None:
                return None 
        return subst
    return None

def unify_var(var, x, subst): 
    """Helper for unification (for FOL)."""
    if var in subst:
        return unify(subst[var], x, subst) 
    elif isinstance(x, str) and x in subst:
        return unify(var, subst[x], subst) 
    elif occur_check(var, x, subst):
        return None 
    else:
        subst[var] = x 
    return subst
    
def occur_check(var, x, subst):
    """Check if variable occurs in expression (for FOL).""" 
    if var == x:
        return True
    elif isinstance(x, list):
        return any(occur_check(var, xi, subst) for xi in x) 
    elif x in subst:
        return occur_check(var, subst[x], subst) 
    return False

def negate(literal):
    """Return negation of a literal. Handles 'P' -> '¬P' and '¬P' -> 'P'.""" 
    if literal[0] == '¬':
        return literal[1:] # remove negation 
    return '¬' + literal

def resolve(ci, cj): 
    """Resolve two clauses (ci and cj).""" 
    resolvents = []
    # Loop over all pairs of literals between the two clauses
    for di in ci: 
        for dj in cj:
            # Check for complementary literals
            if di == negate(dj):
                # Form the new clause by combining and removing the pair
                new_clause = list(set(ci + cj)) 
                new_clause.remove(di) 
                new_clause.remove(dj) 
                resolvents.append(new_clause)
    return resolvents

def pl_resolution(KB, query):
    """Resolution algorithm: returns True if KB ⊨ query.""" 
    # 1. Add the negation of the query to the Knowledge Base
    clauses = KB + [[negate(query)]]
    new = set()

    # 2. Main loop
    while True:
        # Generate all unique pairs of clauses
        pairs = [(clauses[i], clauses[j]) 
                 for i in range(len(clauses)) 
                 for j in range(i + 1, len(clauses))]
        
        # Resolve each pair
        for (ci, cj) in pairs: 
            resolvents = resolve(ci, cj) 
            
            # Check for the empty clause (Contradiction found!)
            if [] in resolvents:
                return True
            
            # Add new resolvents to the 'new' set
            for r in resolvents: 
                new.add(tuple(sorted(r))) # Use tuple/sorted for set comparison

        # Check for termination: no new clauses were generated
        # Convert existing clauses to a set of sorted tuples for comparison
        existing_clauses = set(tuple(sorted(c)) for c in clauses)
        
        if new.issubset(existing_clauses):
            return False # No contradiction found, and no new clauses can be generated
        
        # Add truly new clauses to the main clause list
        for c in new:
            if list(c) not in clauses: 
                clauses.append(list(c))


# --- Example Knowledge Base (KB) and Query ---

# KB:
# 1. P ⇒ Q → represented as [¬P, Q]
# 2. L ∧ M ⇒ P → represented as [¬L, ¬M, P] 
# 3. L
# 4. M
# Query: Q

KB = [
['¬P', 'Q'],
['¬L', '¬M', 'P'], 
['L'],
['M']
]

query = 'Q'

# --- Main Execution ---
if __name__ == "__main__":
    result = pl_resolution(KB, query)

    print(f"Knowledge Base (KB): {KB}")
    print(f"Query: {query}")
    print("\n--- Resolution Result ---")
    print(f"KB entails Query ('{query}')? **{result}**")
